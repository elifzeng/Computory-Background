
总的来说，json在数据读取时需要将整个文件(string type)读进内存，进而转化为number等类型，其数据精度在小数点后6位，它较为通用。
而HDF的结构使其可以只读取指定的部分文件，其数据精度（浮点数保留位数）不受限制，一般在量化领域等使用。

# Json
[Json in wiki](https://en.wikipedia.org/wiki/JSON)
### Introduction
JavaScript Object Notation is an open-standard file format that uses human-readable text to transmit data objects consisting of attribute–value pairs and array data types (or any other serializable value). It is a very common data format, with a diverse range of applications, such as serving as replacement for XML in AJAX systems.

JSON is a language-independent data format. It was derived from JavaScript, but many modern programming languages include code to generate and parse JSON-format data. The official Internet media type for JSON is application/json. JSON filenames use the extension `.json`.

### Data types and syntax

JSON's basic data types are:

**Number**: a signed decimal number that may contain a fractional part and may use exponential E notation, but cannot include non-numbers such as NaN. The format makes no distinction between integer and floating-point. JavaScript uses a double-precision floating-point format for all its numeric values, but other languages implementing JSON may encode numbers differently.
**String**: a sequence of zero or more Unicode characters. Strings are delimited with double-quotation marks and support a backslash escaping syntax.
**Boolean**: either of the values true or false
**Array**: an ordered list of zero or more values, each of which may be of any type. Arrays use square bracket notation with comma-separated elements.
**Object**: an unordered collection of name–value pairs where the names (also called keys) are strings. Objects are intended to represent associative arrays,[7] where each key is unique within an object. Objects are delimited with curly brackets and use commas to separate each pair, while within each pair the colon ':' character separates the key or name from its value.
**null**: An empty value, using the word null
**Whitespace** is allowed and ignored around or between syntactic elements (values and punctuation, but not within a string value). Four specific characters are considered whitespace for this purpose: space, horizontal tab, line feed, and carriage return. In particular, the byte order mark must not be generated by a conforming implementation (though it may be accepted when parsing JSON). JSON does not provide syntax for comments.

Early versions of JSON (such as specified by RFC 4627) required that a valid JSON text must consist of only an object or an array type, which could contain other types within them.
[more to be seen](https://en.wikipedia.org/wiki/JSON)

### Write dictionary with json format
```python
d1 = {
    'a': {
        'a1': {
            1: [0],
            2: [0],
            3: [0]
        },
        'a2': {
            5: [0],
            6: [0],
            7: [0]
        }
    },
    'b': {
        'b1': {
            2: [1],
            3: [1],
            4: [1]
        },
        'b2': {
            6: [1],
            7: [1],
            8: [1]
        }
    },
    'c': {
        'c1': {
            3: [2],
            4: [2],
            5: [2]
        }
    }
}# d1为一个嵌套字典
f = open('a.txt','w')
f.writelines()
f.close()
```
此时`a.txt`中只有第一层字典的key值:
```txt
abc
```
[解决办法](https://www.cnblogs.com/xiexiaokui/p/10788828.html)：  
```python
import json
js = json.dumps(d1) # json.dumps 用于将 Python 对象编码成 JSON 字符串。
f = open(fp,'w')
f.write(js)
f.close()
```
json.dumps()中有几个重要参数：
```python
import json
f = gzip.GzipFile(filename, 'r') # create a file object
f.write(json.dumps(data, indent = 2, sort_keys = True, cls = NumpyEncoder))
```
官方文档：
>(function) dumps: (obj: Any, *, skipkeys: bool = ..., ensure_ascii: bool = ..., check_circular: bool = ..., allow_nan: bool = ..., cls: Type[JSONEncoder] | None = ..., indent: int | str | None = ..., separators: Tuple[str, str] | None = ..., default: (_p0: Any) -> Any | None = ..., sort_keys: bool = ..., **kwds: Any) -> str
>If indent is a non-negative integer, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0 will only insert newlines. None is the most compact representation.
>If *sort_keys* is true (default: False), then the output of dictionaries will be sorted by key.
>No explanation for cls

即`indent`为缩进空格数，`sort_key`为每个key排序依据，2为按开头字母顺序排序。`cls`是可以自定义的encode转换方式，比如将python中的dict转换为json对象。默认的encoder（json.JSONEncoder） 只对部分进行了转化:
```txt
"""Extensible JSON <http://json.org> encoder for Python data structures.

    Supports the following objects and types by default:

    +-------------------+---------------+
    | Python            | JSON          |
    +===================+===============+
    | dict              | object        |
    +-------------------+---------------+
    | list, tuple       | array         |
    +-------------------+---------------+
    | str               | string        |
    +-------------------+---------------+
    | int, float        | number        |
    +-------------------+---------------+
    | True              | true          |
    +-------------------+---------------+
    | False             | false         |
    +-------------------+---------------+
    | None              | null          |
    +-------------------+---------------+

    To extend this to recognize other objects, subclass and implement a
    ``.default()`` method with another method that returns a serializable
    object for ``o`` if possible, otherwise it should call the superclass
    implementation (to raise ``TypeError``).
```
而代码中的[NumpyEncoder](https://pypi.org/project/numpyencoder/)是自定义的另一种转换方式。  
[more details](https://www.cnblogs.com/yxi-liu/p/9579770.html)  

### read and load .json 
[python中json文件处理涉及的四个函数json.dumps()和json.loads()、json.dump()和json.load()的区分](https://www.cnblogs.com/xiaomingzaixian/p/7286793.html)

```python 
# dumps
import json

# json.dumps()函数的使用，将字典转化为字符串
dict1 = {"age": "12"}
json_info = json.dumps(dict1)
print("dict1的类型："+str(type(dict1)))
print("通过json.dumps()函数处理：")
print("json_info的类型："+str(type(json_info)))
# output
dict1的类型：<class 'dict'>
通过json.dumps()函数处理：
json_info的类型：<class 'str'>
```
```python
# loads
import json

# json.loads函数的使用，将字符串转化为字典
json_info = '{"age": "12"}'
dict1 = json.loads(json_info)
print("json_info的类型："+str(type(json_info)))
print("通过json.loads()函数处理：")
print("dict1的类型："+str(type(dict1)))
# output
json_info的类型：<class 'str'>
通过json.loads()函数处理：
dict1的类型：<class 'dict'>
```
```python
# dump
import json

# json.dump()函数的使用，将json信息写进文件
json_info = "{'age': '12'}"
file = open('1.json','w',encoding='utf-8')
json.dump(json_info,file)
#output
json_info
"{'age': '12'}"
```
```python
# load
import json

# json.load()函数的使用，将读取json信息
file = open('1.json','r',encoding='utf-8')
info = json.load(file)
print(info)
# output
{'age': '12'}
```

# Hierarchical Data Format (HDF5)
[HDF in wiki](https://en.wikipedia.org/wiki/Hierarchical_Data_Format)
**Hierarchical Data Format (HDF)** is a set of file formats (HDF4, HDF5) designed to store and organize large amounts of data. Originally developed at the National Center for Supercomputing Applications, it is supported by The HDF Group, a non-profit corporation whose mission is to ensure continued development of HDF5 technologies and the continued accessibility of data stored in HDF.

In keeping with this goal, the HDF libraries and associated tools are available under a liberal, BSD-like license for general use. HDF is supported by many commercial and non-commercial software platforms, including Java, MATLAB, Scilab, Octave, OCaml, Mathematica, IDL, Python, R, Fortran, Common Lisp, and Julia. The freely available HDF distribution consists of the library, command-line utilities, test suite source, Java interface, and the Java-based HDF Viewer (HDFView).
[more to be seen](https://en.wikipedia.org/wiki/Hierarchical_Data_Format)
